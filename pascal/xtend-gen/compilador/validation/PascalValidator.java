/**
 * generated by Xtext 2.15.0
 */
package compilador.validation;

import compilador.pascal.block;
import compilador.pascal.caseListElement;
import compilador.pascal.caseStatement;
import compilador.pascal.conditionalStatement;
import compilador.pascal.constant;
import compilador.pascal.constantChr;
import compilador.pascal.expression;
import compilador.pascal.factor;
import compilador.pascal.functionDeclaration;
import compilador.pascal.functionDesignator;
import compilador.pascal.identifier;
import compilador.pascal.pointerType;
import compilador.pascal.program;
import compilador.pascal.recordType;
import compilador.pascal.simpleType;
import compilador.pascal.stringtype;
import compilador.pascal.structuredType;
import compilador.pascal.subrangeType;
import compilador.pascal.type;
import compilador.pascal.typeDefinition;
import compilador.pascal.typeDefinitionPart;
import compilador.pascal.typeIdentifier;
import compilador.pascal.unpackedStructuredType;
import compilador.pascal.unsignedConstant;
import compilador.pascal.unsignedInteger;
import compilador.pascal.unsignedNumber;
import compilador.pascal.variable;
import compilador.pascal.variableDeclaration;
import compilador.pascal.variableDeclarationPart;
import compilador.validation.AbstractPascalValidator;
import java.util.HashMap;
import java.util.HashSet;
import org.eclipse.emf.common.util.EList;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.InputOutput;
import org.eclipse.xtext.xbase.lib.IterableExtensions;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class PascalValidator extends AbstractPascalValidator {
  private HashMap<String, identifier> variaveisDeclaradas = new HashMap<String, identifier>();
  
  private HashMap<String, String> variaveisTipo = new HashMap<String, String>();
  
  private HashSet<String> tiposCriados = new HashSet<String>();
  
  private HashMap<String, String> funcoesCriadas = new HashMap<String, String>();
  
  @Check
  public void restart(final program init) {
    this.variaveisDeclaradas.clear();
    this.variaveisTipo.clear();
    this.tiposCriados.clear();
    this.funcoesCriadas.clear();
  }
  
  /**
   * -------------------- block -> typeDefinitionPart ----------------------
   */
  @Check
  public void checkDefinicoesTipo(final typeDefinitionPart deftype) {
    typeDefinition _typeDefinition = deftype.getTypeDefinition();
    boolean _tripleNotEquals = (_typeDefinition != null);
    if (_tripleNotEquals) {
      this.checkDefTipo(deftype.getTypeDefinition());
    }
    EList<typeDefinition> definicoes = deftype.getTypeDefinition1();
    boolean _isNullOrEmpty = IterableExtensions.isNullOrEmpty(definicoes);
    boolean _not = (!_isNullOrEmpty);
    if (_not) {
      for (final typeDefinition defPart : definicoes) {
        this.checkDefTipo(defPart);
      }
    }
  }
  
  public Boolean checkDefTipo(final typeDefinition definition) {
    boolean _xblockexpression = false;
    {
      String tipoCriado = definition.getIdentifier().getIdentifier();
      InputOutput.<String>println(tipoCriado);
      boolean _xifexpression = false;
      boolean _contains = this.tiposCriados.contains(tipoCriado);
      if (_contains) {
        this.error(("um tipo ja foi criado com id " + tipoCriado), null);
      } else {
        _xifexpression = this.tiposCriados.add(tipoCriado);
      }
      _xblockexpression = _xifexpression;
    }
    return Boolean.valueOf(_xblockexpression);
  }
  
  /**
   * variableDeclaration: Podemos declarar mais de uma variavel usando apenas uma palavra chave 'var',
   *  Ex: var nome1, nome2...
   *  Então colocamos o id dessas variaveis no map, caso ja exista, retornar um erro de id duplicado
   *  Ao percorrer a lista, adicionar no mapa a variavel e o seu tipo declarado
   */
  public String checkDeclaracaoVariavel(final variableDeclaration vd) {
    String _xblockexpression = null;
    {
      EList<identifier> declaracoes = vd.getIdentifierList().getIdentifierList1();
      identifier declaracaoUnica = vd.getIdentifierList().getIdentifier();
      boolean _isNullOrEmpty = IterableExtensions.isNullOrEmpty(declaracoes);
      boolean _not = (!_isNullOrEmpty);
      if (_not) {
        for (final identifier id : declaracoes) {
          boolean _jaDeclarada = this.jaDeclarada(id);
          if (_jaDeclarada) {
            String _identifier = id.getIdentifier();
            String _plus = ("id variavel duplicado: " + _identifier);
            this.error(_plus, null, id.getIdentifier());
          } else {
            this.variaveisDeclaradas.put(id.getIdentifier(), id);
            this.variaveisTipo.put(id.getIdentifier(), this.getTypeVar(vd.getType()));
          }
        }
      }
      String _xifexpression = null;
      if (((declaracaoUnica != null) && this.jaDeclarada(declaracaoUnica))) {
        String _identifier_1 = declaracaoUnica.getIdentifier();
        String _plus_1 = ("id variavel duplicado: " + _identifier_1);
        this.error(_plus_1, null, declaracaoUnica.getIdentifier());
      } else {
        String _xblockexpression_1 = null;
        {
          this.variaveisDeclaradas.put(declaracaoUnica.getIdentifier(), declaracaoUnica);
          InputOutput.<String>println(declaracaoUnica.getIdentifier());
          _xblockexpression_1 = this.variaveisTipo.put(declaracaoUnica.getIdentifier(), this.getTypeVar(vd.getType()));
        }
        _xifexpression = _xblockexpression_1;
      }
      _xblockexpression = _xifexpression;
    }
    return _xblockexpression;
  }
  
  public boolean jaDeclarada(final identifier variavel) {
    return this.variaveisDeclaradas.containsKey(variavel.getIdentifier());
  }
  
  public String getTypeVar(final type tipoVariavel) {
    simpleType _simpleType = tipoVariavel.getSimpleType();
    boolean _tripleNotEquals = (_simpleType != null);
    if (_tripleNotEquals) {
      return this.getSimpleType(tipoVariavel);
    }
    structuredType _structuredType = tipoVariavel.getStructuredType();
    boolean _tripleNotEquals_1 = (_structuredType != null);
    if (_tripleNotEquals_1) {
      return this.getStructuredType(tipoVariavel.getStructuredType());
    }
    pointerType _pointerType = tipoVariavel.getPointerType();
    boolean _tripleNotEquals_2 = (_pointerType != null);
    if (_tripleNotEquals_2) {
      return this.getPointerType(tipoVariavel.getPointerType());
    }
    return null;
  }
  
  public String getSimpleType(final type st) {
    Object _xblockexpression = null;
    {
      subrangeType _subrangeType = st.getSimpleType().getSubrangeType();
      boolean _tripleNotEquals = (_subrangeType != null);
      if (_tripleNotEquals) {
        if (((st.getSimpleType().getSubrangeType().getConstant() != null) && (st.getSimpleType().getSubrangeType().getConstant2() != null))) {
          return "range";
        } else {
          this.error("sao necessarias duas constantes para  intervalo", null);
        }
      }
      typeIdentifier _typeIdentifier = st.getSimpleType().getTypeIdentifier();
      boolean _tripleNotEquals_1 = (_typeIdentifier != null);
      if (_tripleNotEquals_1) {
        return this.getTypeTypeIdentifier(st.getSimpleType().getTypeIdentifier());
      }
      Object _xifexpression = null;
      stringtype _stringtype = st.getSimpleType().getStringtype();
      boolean _tripleNotEquals_2 = (_stringtype != null);
      if (_tripleNotEquals_2) {
        _xifexpression = null;
      }
      _xblockexpression = _xifexpression;
    }
    return ((String)_xblockexpression);
  }
  
  public String getTypeTypeIdentifier(final typeIdentifier ti) {
    String _char = ti.getChar();
    boolean _tripleNotEquals = (_char != null);
    if (_tripleNotEquals) {
      return ti.getChar();
    }
    String _boolean = ti.getBoolean();
    boolean _tripleNotEquals_1 = (_boolean != null);
    if (_tripleNotEquals_1) {
      return ti.getBoolean();
    }
    String _integer = ti.getInteger();
    boolean _tripleNotEquals_2 = (_integer != null);
    if (_tripleNotEquals_2) {
      return ti.getInteger();
    }
    String _real = ti.getReal();
    boolean _tripleNotEquals_3 = (_real != null);
    if (_tripleNotEquals_3) {
      return ti.getReal();
    }
    String _string = ti.getString();
    boolean _tripleNotEquals_4 = (_string != null);
    if (_tripleNotEquals_4) {
      return ti.getString();
    }
    identifier _identifier = ti.getIdentifier();
    boolean _tripleNotEquals_5 = (_identifier != null);
    if (_tripleNotEquals_5) {
      boolean _contains = this.tiposCriados.contains(ti.getIdentifier().getIdentifier());
      boolean _not = (!_contains);
      if (_not) {
        String _identifier_1 = ti.getIdentifier().getIdentifier();
        String _plus = ("tipo " + _identifier_1);
        String _plus_1 = (_plus + " nao existe!");
        this.error(_plus_1, null);
      } else {
        return ti.getIdentifier().getIdentifier();
      }
    }
    return null;
  }
  
  /**
   * Retonar o tipo "record" da variavel, como na declaracao queremos apenas guardar qual o tipo daquela variavel
   * será guardado no mapa de declaracao <identifier, "record">
   */
  public String getStructuredType(final structuredType type) {
    Object _xblockexpression = null;
    {
      EList<unpackedStructuredType> unpackeds = type.getUnpackedStructuredType1();
      Object _xifexpression = null;
      boolean _isNullOrEmpty = IterableExtensions.isNullOrEmpty(unpackeds);
      boolean _not = (!_isNullOrEmpty);
      if (_not) {
        for (final unpackedStructuredType t : unpackeds) {
          {
            recordType possivelRecord = t.getRecordType();
            if ((possivelRecord != null)) {
              return "record";
            }
          }
        }
      }
      _xblockexpression = _xifexpression;
    }
    return ((String)_xblockexpression);
  }
  
  public String getPointerType(final pointerType type) {
    String _pointerType = this.getPointerType(type);
    boolean _tripleNotEquals = (_pointerType != null);
    if (_tripleNotEquals) {
      return "^";
    }
    return null;
  }
  
  /**
   * variableDeclarationPart: Pode ter varias declaracoes:
   * 		Ex: var....; var ....;
   * Se for so uma, chama o metodo que verifica a declaracao
   * Se for uma lista, fazer um for na mesma e chamar o metodo que verifica a declaracao pra cada uma
   */
  @Check
  public void checkDeclaracao(final variableDeclarationPart decla) {
    variableDeclaration declaracaoUmaVar = decla.getVariableDeclaration();
    EList<variableDeclaration> listaDeclaracoes = decla.getVariableDeclaration1();
    if ((declaracaoUmaVar != null)) {
      this.checkDeclaracaoVariavel(declaracaoUmaVar);
    }
    boolean _isNullOrEmpty = IterableExtensions.isNullOrEmpty(listaDeclaracoes);
    boolean _not = (!_isNullOrEmpty);
    if (_not) {
      for (final variableDeclaration declaracao : listaDeclaracoes) {
        this.checkDeclaracaoVariavel(declaracao);
      }
    }
  }
  
  @Check
  public void checkConditionalStatement(final conditionalStatement cst) {
    caseStatement caseStatement = cst.getCaseStatement();
    String expType = this.checkExpressionType(caseStatement.getExpression());
    InputOutput.<String>println(expType);
    boolean _isEmpty = expType.isEmpty();
    if (_isEmpty) {
      this.error("variavel nao declarada. tipo do case invalido", null);
    }
    String tipoCaseUnico = this.getCaseListUnico(caseStatement.getCaseListElement());
    boolean tipoCaseLista = this.checkCaseList(caseStatement.getCaseListElement1(), tipoCaseUnico);
    if ((tipoCaseUnico.isEmpty() || (!tipoCaseLista))) {
      this.error("Tipos incompativeis", null);
    }
  }
  
  public boolean checkCaseList(final EList<caseListElement> list, final String expType) {
    boolean isValido = true;
    for (final caseListElement e : list) {
      if ((this.getCaseListUnico(e).isEmpty() || (this.getCaseListUnico(e) != expType))) {
        isValido = false;
      }
    }
    return isValido;
  }
  
  public String getCaseListUnico(final caseListElement element) {
    constant constUnica = element.getConstList().getConstant();
    EList<constant> constLista = element.getConstList().getConstant1();
    String tipoPrincipal = this.getTypeConst(constUnica);
    if ((constUnica != null)) {
      return tipoPrincipal;
    }
    for (final constant e : constLista) {
      {
        String tipoElement = this.getTypeConst(e);
        if ((tipoPrincipal != tipoElement)) {
          return "";
        }
      }
    }
    return tipoPrincipal;
  }
  
  public String getTypeConst(final constant c) {
    unsignedInteger _unsignedInteger = c.getNumber().getUnsignedInteger();
    boolean _tripleNotEquals = (_unsignedInteger != null);
    if (_tripleNotEquals) {
      return "integer";
    }
    String _unsignedReal = c.getNumber().getUnsignedReal();
    boolean _tripleNotEquals_1 = (_unsignedReal != null);
    if (_tripleNotEquals_1) {
      return "real";
    }
    identifier _identifier = c.getIdentifier();
    boolean _tripleNotEquals_2 = (_identifier != null);
    if (_tripleNotEquals_2) {
    }
    String _sTRING_LITERAL = c.getSTRING_LITERAL();
    boolean _tripleNotEquals_3 = (_sTRING_LITERAL != null);
    if (_tripleNotEquals_3) {
      return "string";
    }
    constantChr _constantChr = c.getConstantChr();
    boolean _tripleNotEquals_4 = (_constantChr != null);
    if (_tripleNotEquals_4) {
      return "char";
    }
    String _bool = c.getBool();
    boolean _tripleNotEquals_5 = (_bool != null);
    if (_tripleNotEquals_5) {
      return "bool";
    }
    return null;
  }
  
  public String checkExpressionType(final expression expression) {
    String tipoExp = "";
    factor simple = expression.getSimpleExpression().getTerm().getSignedFactor().getFactor();
    unsignedConstant _unsignedConstant = simple.getUnsignedConstant();
    boolean _tripleNotEquals = (_unsignedConstant != null);
    if (_tripleNotEquals) {
      tipoExp = this.getTypeUnsignedConst(simple.getUnsignedConstant());
    }
    factor _factor = simple.getFactor();
    boolean _tripleNotEquals_1 = (_factor != null);
    if (_tripleNotEquals_1) {
      tipoExp = "boolean";
    }
    String _bool = simple.getBool();
    boolean _tripleNotEquals_2 = (_bool != null);
    if (_tripleNotEquals_2) {
      tipoExp = "boolean";
    }
    functionDesignator _functionDesignator = simple.getFunctionDesignator();
    boolean _tripleNotEquals_3 = (_functionDesignator != null);
    if (_tripleNotEquals_3) {
      String funcao = this.funcoesCriadas.get(simple.getFunctionDesignator().getIdentifier().getIdentifier());
      if (((funcao != null) && (!funcao.isEmpty()))) {
        tipoExp = funcao;
      } else {
        this.error("funcao nao declarada", null);
        return "";
      }
    }
    variable _variable = simple.getVariable();
    boolean _tripleNotEquals_4 = (_variable != null);
    if (_tripleNotEquals_4) {
      tipoExp = this.getTypeVariable(simple.getVariable());
    }
    compilador.pascal.expression _expression = simple.getExpression();
    boolean _tripleNotEquals_5 = (_expression != null);
    if (_tripleNotEquals_5) {
      tipoExp = this.checkExpressionType(simple.getExpression());
    }
    String _relationaloperator = expression.getRelationaloperator();
    boolean _tripleNotEquals_6 = (_relationaloperator != null);
    if (_tripleNotEquals_6) {
      tipoExp = "boolean";
    }
    String _additiveoperator = expression.getSimpleExpression().getAdditiveoperator();
    boolean _tripleNotEquals_7 = (_additiveoperator != null);
    if (_tripleNotEquals_7) {
      tipoExp = "integer";
    }
    String _multiplicativeoperator = expression.getSimpleExpression().getTerm().getMultiplicativeoperator();
    boolean _tripleNotEquals_8 = (_multiplicativeoperator != null);
    if (_tripleNotEquals_8) {
      tipoExp = "integer";
    }
    return tipoExp;
  }
  
  public String getTypeUnsignedConst(final unsignedConstant constant) {
    unsignedNumber _unsignedNumber = constant.getUnsignedNumber();
    boolean _tripleNotEquals = (_unsignedNumber != null);
    if (_tripleNotEquals) {
      unsignedInteger _unsignedInteger = constant.getUnsignedNumber().getUnsignedInteger();
      boolean _tripleNotEquals_1 = (_unsignedInteger != null);
      if (_tripleNotEquals_1) {
        return "integer";
      }
      String _unsignedReal = constant.getUnsignedNumber().getUnsignedReal();
      boolean _tripleNotEquals_2 = (_unsignedReal != null);
      if (_tripleNotEquals_2) {
        return "real";
      }
    }
    String _string_literal = constant.getString_literal();
    boolean _tripleNotEquals_3 = (_string_literal != null);
    if (_tripleNotEquals_3) {
      return "string";
    }
    constantChr _constantChr = constant.getConstantChr();
    boolean _tripleNotEquals_4 = (_constantChr != null);
    if (_tripleNotEquals_4) {
      return "integer";
    }
    return null;
  }
  
  public String getTypeVariable(final variable variable) {
    String possivelTipoDeclarado = variable.getIdentifier().getIdentifier();
    boolean _containsKey = this.variaveisDeclaradas.containsKey(possivelTipoDeclarado);
    if (_containsKey) {
      return this.variaveisDeclaradas.get(possivelTipoDeclarado).getIdentifier();
    } else {
      return "";
    }
  }
  
  @Check
  public String registerFunction(final functionDeclaration funcDecl) {
    String _xifexpression = null;
    boolean _containsKey = this.funcoesCriadas.containsKey(funcDecl.getIdentifier().getIdentifier());
    if (_containsKey) {
      String _identifier = funcDecl.getIdentifier().getIdentifier();
      String _plus = ("funcao de nome " + _identifier);
      String _plus_1 = (_plus + " já existe");
      this.error(_plus_1, null);
    } else {
      _xifexpression = this.funcoesCriadas.put(funcDecl.getIdentifier().getIdentifier(), this.getTypeTypeIdentifier(funcDecl.getTypeIdentifier()));
    }
    return _xifexpression;
  }
  
  @Check
  public Object runChecks(final block b) {
    return null;
  }
}
