/*
 * generated by Xtext 2.15.0
 */
package compilador.validation

import org.eclipse.xtext.validation.Check
import compilador.pascal.caseStatement;
import compilador.pascal.*;

import java.util.HashMap
import java.util.Map
import compilador.pascal.structuredType
import compilador.pascal.pointerType
import compilador.pascal.identifier
import compilador.pascal.recordType
import java.util.HashSet

/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class PascalValidator extends AbstractPascalValidator {

	var variaveisDeclaradas = new HashMap<String, identifier>();
	var variaveisTipo = new HashMap<String, String>();
	var tiposCriados = new HashSet<String>();

	@Check
	def restart(program init) {
		variaveisDeclaradas.clear();
		variaveisTipo.clear();
	}

	/* -------------------- block ----------------------  */
	/* -------------------- block -> variableDeclarationPart ----------------------  */
	/**
	 * variableDeclaration: Podemos declarar mais de uma variavel usando apenas uma palavra chave 'var',
	 *  Ex: var nome1, nome2...
	 *  Então colocamos o id dessas variaveis no map, caso ja exista, retornar um erro de id duplicado
	 *  Ao percorrer a lista, adicionar no mapa a variavel e o seu tipo declarado
	 */
	def checkDeclaracaoVariavel(variableDeclaration vd) {
		var declaracoes = vd.identifierList.identifierList1;
		var declaracaoUnica = vd.identifierList.identifier;

		if (!declaracoes.isNullOrEmpty()) {
			for (identifier id : declaracoes) {
				if (jaDeclarada(id)) {
					error("id variavel duplicado: " + id.identifier, null, id.identifier);
				} else {
					variaveisDeclaradas.put(id.identifier, id);
					variaveisTipo.put(id.identifier, getTypeVar(vd.type));
				}
			}
		}
		if (declaracaoUnica !== null && jaDeclarada(declaracaoUnica)) {
			error("id variavel duplicado: " + declaracaoUnica.identifier, null, declaracaoUnica.identifier);
		} else {
			variaveisDeclaradas.put(declaracaoUnica.identifier, declaracaoUnica);
			println(declaracaoUnica.identifier);
			variaveisTipo.put(declaracaoUnica.identifier, getTypeVar(vd.type));
		}

	}

	def boolean jaDeclarada(identifier variavel) {
		return (this.variaveisDeclaradas.containsKey(variavel.identifier))
	}

	def String getTypeVar(type tipoVariavel) {

		if (tipoVariavel.simpleType !== null) {
			return getSimpleType(tipoVariavel.simpleType);
		}
		if (tipoVariavel.structuredType !== null) {
			return getStructuredType(tipoVariavel.structuredType);
		}

		if (tipoVariavel.pointerType !== null) {
			return getPointerType(tipoVariavel.pointerType);
		}
	}

	def getSimpleType(simpleType st) {
		// scalarType   TO-DO: NÃO ENTENDI MUITO BEM COMO FUNCIONA ESSE SCALARTYPE ://
		// subrangeType
		if (st.subrangeType !== null) {
			if (st.subrangeType.constant !== null && st.subrangeType.constant2 !== null) {
				return "range";
			} else {
				error("sao necessarias duas constantes para  intervalo", null);
			}
		}

		// typeIdentifier
		if (st.typeIdentifier !== null) {
			if (st.typeIdentifier.char !== null) {
				return (st.typeIdentifier.char);
			}

			if (st.typeIdentifier.boolean !== null) {
				return (st.typeIdentifier.boolean);
			}
			if (st.typeIdentifier.integer !== null) {
				return (st.typeIdentifier.integer);
			}
			if (st.typeIdentifier.real !== null) {
				return (st.typeIdentifier.real);
			}
			if (st.typeIdentifier.string !== null) {
				return (st.typeIdentifier.string);
			}

			if (st.typeIdentifier.identifier !== null) {
				if (!tiposCriados.contains(st.typeIdentifier.identifier)) {
					error("tipo " + st.typeIdentifier.identifier + " nao existe!", null);
				} else {
					return st.typeIdentifier.identifier.identifier;
				}
			// Verificacao pra quando sao criados tipos durante o programa,
			// precisa criar um Map de "tipos criados pra fazer essa verificação					
			}
		}

		if (st.stringtype !== null) {
//			return st.stringtype;
		}
	// stringType
	//
	}

	/**
	 * Retonar o tipo "record" da variavel, como na declaracao queremos apenas guardar qual o tipo daquela variavel
	 * será guardado no mapa de declaracao <identifier, "record">
	 */
	def String getStructuredType(structuredType type) {
		// Record eh structured type, nao sei seprecisaria verificar array, set, etc... 
		var unpackeds = type.unpackedStructuredType1;
		println(">>>" + type);
		if (!unpackeds.isNullOrEmpty()) {
			for (unpackedStructuredType t : unpackeds) {
				var possivelRecord = t.recordType;

				if (possivelRecord !== null) {
					return "record";
				}
			}
		}
	}

	def String getPointerType(pointerType type) {
		if (type.pointerType !== null) {
			return "^"
		}
	}

	/**
	 * variableDeclarationPart: Pode ter varias declaracoes: 
	 * 		Ex: var....; var ....;
	 * Se for so uma, chama o metodo que verifica a declaracao
	 * Se for uma lista, fazer um for na mesma e chamar o metodo que verifica a declaracao pra cada uma
	 */
	@Check
	def checkDeclaracao(variableDeclarationPart decla) {
		var declaracaoUmaVar = decla.variableDeclaration;
		var listaDeclaracoes = decla.variableDeclaration1;

		if (declaracaoUmaVar !== null) {
			checkDeclaracaoVariavel(declaracaoUmaVar);
		}

		if (!listaDeclaracoes.isNullOrEmpty()) {
			for (variableDeclaration declaracao : listaDeclaracoes) {
				checkDeclaracaoVariavel(declaracao);
			}
		}

	}

	/* -------------------- block -> typeDefinitionPart ----------------------  */
	@Check
	def checkDefinicaoTipo(typeDefinitionPart deftype) {
		var definicoes = deftype.typeDefinition1;
		if (!definicoes.isNullOrEmpty()) {
			for (defPart : definicoes) {
				
			}
		}

	}

	@Check
	def runChecks(block b) {
//		var declaracoes = b.variableDeclarationParts;
//		for (variableDeclarationPart e : declaracoes) {
//			checkDeclaracao(e);
//		}
	}
}
