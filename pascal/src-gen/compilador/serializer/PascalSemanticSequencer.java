/*
 * generated by Xtext 2.15.0
 */
package compilador.serializer;

import com.google.inject.Inject;
import compilador.pascal.PascalPackage;
import compilador.pascal.actualParameter;
import compilador.pascal.assignmentStatement;
import compilador.pascal.block;
import compilador.pascal.caseListElement;
import compilador.pascal.caseStatement;
import compilador.pascal.conditionalStatement;
import compilador.pascal.constList;
import compilador.pascal.constant;
import compilador.pascal.constantChr;
import compilador.pascal.constantDefinition;
import compilador.pascal.constantDefinitionPart;
import compilador.pascal.expression;
import compilador.pascal.factor;
import compilador.pascal.fieldList;
import compilador.pascal.fixedPart;
import compilador.pascal.formalParameterList;
import compilador.pascal.formalParameterSection;
import compilador.pascal.functionDeclaration;
import compilador.pascal.functionDesignator;
import compilador.pascal.functionType;
import compilador.pascal.gotoStatement;
import compilador.pascal.identifierList;
import compilador.pascal.label;
import compilador.pascal.parameterGroup;
import compilador.pascal.pascal;
import compilador.pascal.pointerType;
import compilador.pascal.procedureAndFunctionDeclarationPart;
import compilador.pascal.procedureDeclaration;
import compilador.pascal.procedureOrFunctionDeclaration;
import compilador.pascal.procedureType;
import compilador.pascal.program;
import compilador.pascal.programHeading;
import compilador.pascal.recordSection;
import compilador.pascal.recordType;
import compilador.pascal.scalarType;
import compilador.pascal.signedFactor;
import compilador.pascal.simpleExpression;
import compilador.pascal.simpleStatement;
import compilador.pascal.simpleType;
import compilador.pascal.statement;
import compilador.pascal.statements;
import compilador.pascal.stringtype;
import compilador.pascal.structuredStatement;
import compilador.pascal.structuredType;
import compilador.pascal.subrangeType;
import compilador.pascal.tag;
import compilador.pascal.term;
import compilador.pascal.type;
import compilador.pascal.typeDefinition;
import compilador.pascal.typeDefinitionPart;
import compilador.pascal.typeIdentifier;
import compilador.pascal.unlabelledStatement;
import compilador.pascal.unpackedStructuredType;
import compilador.pascal.unsignedConstant;
import compilador.pascal.unsignedInteger;
import compilador.pascal.unsignedNumber;
import compilador.pascal.usesUnitsPart;
import compilador.pascal.variable;
import compilador.pascal.variableDeclaration;
import compilador.pascal.variableDeclarationPart;
import compilador.pascal.variantPart;
import compilador.services.PascalGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class PascalSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private PascalGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == PascalPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case PascalPackage.ACTUAL_PARAMETER:
				if (rule == grammarAccess.getActualParameterRule()) {
					sequence_actualParameter(context, (actualParameter) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getParameterListRule()) {
					sequence_actualParameter_parameterList(context, (actualParameter) semanticObject); 
					return; 
				}
				else break;
			case PascalPackage.ASSIGNMENT_STATEMENT:
				sequence_assignmentStatement(context, (assignmentStatement) semanticObject); 
				return; 
			case PascalPackage.BLOCK:
				sequence_block(context, (block) semanticObject); 
				return; 
			case PascalPackage.CASE_LIST_ELEMENT:
				sequence_caseListElement(context, (caseListElement) semanticObject); 
				return; 
			case PascalPackage.CASE_STATEMENT:
				sequence_caseStatement(context, (caseStatement) semanticObject); 
				return; 
			case PascalPackage.CONDITIONAL_STATEMENT:
				sequence_conditionalStatement(context, (conditionalStatement) semanticObject); 
				return; 
			case PascalPackage.CONST_LIST:
				sequence_constList(context, (constList) semanticObject); 
				return; 
			case PascalPackage.CONSTANT:
				if (rule == grammarAccess.getConstantRule()) {
					sequence_constant(context, (constant) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getVariantRule()) {
					sequence_constant_variant(context, (constant) semanticObject); 
					return; 
				}
				else break;
			case PascalPackage.CONSTANT_CHR:
				sequence_constantChr(context, (constantChr) semanticObject); 
				return; 
			case PascalPackage.CONSTANT_DEFINITION:
				sequence_constantDefinition(context, (constantDefinition) semanticObject); 
				return; 
			case PascalPackage.CONSTANT_DEFINITION_PART:
				sequence_constantDefinitionPart(context, (constantDefinitionPart) semanticObject); 
				return; 
			case PascalPackage.EXPRESSION:
				sequence_expression(context, (expression) semanticObject); 
				return; 
			case PascalPackage.FACTOR:
				sequence_factor(context, (factor) semanticObject); 
				return; 
			case PascalPackage.FIELD_LIST:
				sequence_fieldList(context, (fieldList) semanticObject); 
				return; 
			case PascalPackage.FIXED_PART:
				sequence_fixedPart(context, (fixedPart) semanticObject); 
				return; 
			case PascalPackage.FORMAL_PARAMETER_LIST:
				sequence_formalParameterList(context, (formalParameterList) semanticObject); 
				return; 
			case PascalPackage.FORMAL_PARAMETER_SECTION:
				sequence_formalParameterSection(context, (formalParameterSection) semanticObject); 
				return; 
			case PascalPackage.FUNCTION_DECLARATION:
				sequence_functionDeclaration(context, (functionDeclaration) semanticObject); 
				return; 
			case PascalPackage.FUNCTION_DESIGNATOR:
				sequence_functionDesignator(context, (functionDesignator) semanticObject); 
				return; 
			case PascalPackage.FUNCTION_TYPE:
				sequence_functionType(context, (functionType) semanticObject); 
				return; 
			case PascalPackage.GOTO_STATEMENT:
				sequence_gotoStatement(context, (gotoStatement) semanticObject); 
				return; 
			case PascalPackage.IDENTIFIER_LIST:
				sequence_identifierList(context, (identifierList) semanticObject); 
				return; 
			case PascalPackage.LABEL:
				if (rule == grammarAccess.getLabelRule()) {
					sequence_label(context, (label) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getLabel_declaration_partRule()) {
					sequence_label_label_declaration_part(context, (label) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStatementRule()) {
					sequence_label_statement(context, (label) semanticObject); 
					return; 
				}
				else break;
			case PascalPackage.PARAMETER_GROUP:
				sequence_parameterGroup(context, (parameterGroup) semanticObject); 
				return; 
			case PascalPackage.PASCAL:
				sequence_pascal(context, (pascal) semanticObject); 
				return; 
			case PascalPackage.POINTER_TYPE:
				sequence_pointerType(context, (pointerType) semanticObject); 
				return; 
			case PascalPackage.PROCEDURE_AND_FUNCTION_DECLARATION_PART:
				sequence_procedureAndFunctionDeclarationPart(context, (procedureAndFunctionDeclarationPart) semanticObject); 
				return; 
			case PascalPackage.PROCEDURE_DECLARATION:
				sequence_procedureDeclaration(context, (procedureDeclaration) semanticObject); 
				return; 
			case PascalPackage.PROCEDURE_OR_FUNCTION_DECLARATION:
				sequence_procedureOrFunctionDeclaration(context, (procedureOrFunctionDeclaration) semanticObject); 
				return; 
			case PascalPackage.PROCEDURE_TYPE:
				sequence_procedureType(context, (procedureType) semanticObject); 
				return; 
			case PascalPackage.PROGRAM:
				sequence_program(context, (program) semanticObject); 
				return; 
			case PascalPackage.PROGRAM_HEADING:
				sequence_programHeading(context, (programHeading) semanticObject); 
				return; 
			case PascalPackage.RECORD_SECTION:
				sequence_recordSection(context, (recordSection) semanticObject); 
				return; 
			case PascalPackage.RECORD_TYPE:
				sequence_recordType(context, (recordType) semanticObject); 
				return; 
			case PascalPackage.SCALAR_TYPE:
				sequence_scalarType(context, (scalarType) semanticObject); 
				return; 
			case PascalPackage.SIGNED_FACTOR:
				sequence_signedFactor(context, (signedFactor) semanticObject); 
				return; 
			case PascalPackage.SIMPLE_EXPRESSION:
				sequence_simpleExpression(context, (simpleExpression) semanticObject); 
				return; 
			case PascalPackage.SIMPLE_STATEMENT:
				sequence_simpleStatement(context, (simpleStatement) semanticObject); 
				return; 
			case PascalPackage.SIMPLE_TYPE:
				sequence_simpleType(context, (simpleType) semanticObject); 
				return; 
			case PascalPackage.STATEMENT:
				sequence_statement(context, (statement) semanticObject); 
				return; 
			case PascalPackage.STATEMENTS:
				sequence_statements(context, (statements) semanticObject); 
				return; 
			case PascalPackage.STRINGTYPE:
				sequence_stringtype(context, (stringtype) semanticObject); 
				return; 
			case PascalPackage.STRUCTURED_STATEMENT:
				sequence_structuredStatement(context, (structuredStatement) semanticObject); 
				return; 
			case PascalPackage.STRUCTURED_TYPE:
				sequence_structuredType(context, (structuredType) semanticObject); 
				return; 
			case PascalPackage.SUBRANGE_TYPE:
				sequence_subrangeType(context, (subrangeType) semanticObject); 
				return; 
			case PascalPackage.TAG:
				sequence_tag(context, (tag) semanticObject); 
				return; 
			case PascalPackage.TERM:
				sequence_term(context, (term) semanticObject); 
				return; 
			case PascalPackage.TYPE:
				sequence_type(context, (type) semanticObject); 
				return; 
			case PascalPackage.TYPE_DEFINITION:
				sequence_typeDefinition(context, (typeDefinition) semanticObject); 
				return; 
			case PascalPackage.TYPE_DEFINITION_PART:
				sequence_typeDefinitionPart(context, (typeDefinitionPart) semanticObject); 
				return; 
			case PascalPackage.TYPE_IDENTIFIER:
				sequence_typeIdentifier(context, (typeIdentifier) semanticObject); 
				return; 
			case PascalPackage.UNLABELLED_STATEMENT:
				sequence_unlabelledStatement(context, (unlabelledStatement) semanticObject); 
				return; 
			case PascalPackage.UNPACKED_STRUCTURED_TYPE:
				sequence_unpackedStructuredType(context, (unpackedStructuredType) semanticObject); 
				return; 
			case PascalPackage.UNSIGNED_CONSTANT:
				sequence_unsignedConstant(context, (unsignedConstant) semanticObject); 
				return; 
			case PascalPackage.UNSIGNED_INTEGER:
				sequence_unsignedInteger(context, (unsignedInteger) semanticObject); 
				return; 
			case PascalPackage.UNSIGNED_NUMBER:
				sequence_unsignedNumber(context, (unsignedNumber) semanticObject); 
				return; 
			case PascalPackage.USES_UNITS_PART:
				sequence_usesUnitsPart(context, (usesUnitsPart) semanticObject); 
				return; 
			case PascalPackage.VARIABLE:
				sequence_variable(context, (variable) semanticObject); 
				return; 
			case PascalPackage.VARIABLE_DECLARATION:
				sequence_variableDeclaration(context, (variableDeclaration) semanticObject); 
				return; 
			case PascalPackage.VARIABLE_DECLARATION_PART:
				sequence_variableDeclarationPart(context, (variableDeclarationPart) semanticObject); 
				return; 
			case PascalPackage.VARIANT_PART:
				sequence_variantPart(context, (variantPart) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     actualParameter returns actualParameter
	 *
	 * Constraint:
	 *     expression=expression
	 */
	protected void sequence_actualParameter(ISerializationContext context, actualParameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.ACTUAL_PARAMETER__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.ACTUAL_PARAMETER__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getActualParameterAccess().getExpressionExpressionParserRuleCall_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     parameterList returns actualParameter
	 *
	 * Constraint:
	 *     (expression=expression actualParameter+=actualParameter*)
	 */
	protected void sequence_actualParameter_parameterList(ISerializationContext context, actualParameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     assignmentStatement returns assignmentStatement
	 *
	 * Constraint:
	 *     (variable=variable expression=expression)
	 */
	protected void sequence_assignmentStatement(ISerializationContext context, assignmentStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.ASSIGNMENT_STATEMENT__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.ASSIGNMENT_STATEMENT__VARIABLE));
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.ASSIGNMENT_STATEMENT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.ASSIGNMENT_STATEMENT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignmentStatementAccess().getVariableVariableParserRuleCall_0_0(), semanticObject.getVariable());
		feeder.accept(grammarAccess.getAssignmentStatementAccess().getExpressionExpressionParserRuleCall_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     block returns block
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             label+=label_declaration_part | 
	 *             constantDefinitionPart+=constantDefinitionPart | 
	 *             typeDefinitionPart+=typeDefinitionPart | 
	 *             variableDeclarationPart+=variableDeclarationPart | 
	 *             procedureAndFunctionDeclarationPart+=procedureAndFunctionDeclarationPart | 
	 *             usesUnitsPart+=usesUnitsPart
	 *         )* 
	 *         compoundStatement=compoundStatement
	 *     )
	 */
	protected void sequence_block(ISerializationContext context, block semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     caseListElement returns caseListElement
	 *
	 * Constraint:
	 *     (constList=constList statement=statement)
	 */
	protected void sequence_caseListElement(ISerializationContext context, caseListElement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.CASE_LIST_ELEMENT__CONST_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.CASE_LIST_ELEMENT__CONST_LIST));
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.CASE_LIST_ELEMENT__STATEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.CASE_LIST_ELEMENT__STATEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCaseListElementAccess().getConstListConstListParserRuleCall_0_0(), semanticObject.getConstList());
		feeder.accept(grammarAccess.getCaseListElementAccess().getStatementStatementParserRuleCall_2_0(), semanticObject.getStatement());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     caseStatement returns caseStatement
	 *
	 * Constraint:
	 *     (expression=expression caseListElement=caseListElement caseListElement1+=caseListElement* statements=statements?)
	 */
	protected void sequence_caseStatement(ISerializationContext context, caseStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     conditionalStatement returns conditionalStatement
	 *
	 * Constraint:
	 *     caseStatement=caseStatement
	 */
	protected void sequence_conditionalStatement(ISerializationContext context, conditionalStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.CONDITIONAL_STATEMENT__CASE_STATEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.CONDITIONAL_STATEMENT__CASE_STATEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConditionalStatementAccess().getCaseStatementCaseStatementParserRuleCall_0(), semanticObject.getCaseStatement());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     constList returns constList
	 *
	 * Constraint:
	 *     (constant=constant constant1+=constant*)
	 */
	protected void sequence_constList(ISerializationContext context, constList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     constantChr returns constantChr
	 *
	 * Constraint:
	 *     unsignedInteger=unsignedInteger
	 */
	protected void sequence_constantChr(ISerializationContext context, constantChr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.CONSTANT_CHR__UNSIGNED_INTEGER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.CONSTANT_CHR__UNSIGNED_INTEGER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConstantChrAccess().getUnsignedIntegerUnsignedIntegerParserRuleCall_2_0(), semanticObject.getUnsignedInteger());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     constantDefinitionPart returns constantDefinitionPart
	 *
	 * Constraint:
	 *     constantDefinition+=constantDefinition+
	 */
	protected void sequence_constantDefinitionPart(ISerializationContext context, constantDefinitionPart semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     constantDefinition returns constantDefinition
	 *
	 * Constraint:
	 *     (identifier=identifier constant=constant)
	 */
	protected void sequence_constantDefinition(ISerializationContext context, constantDefinition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.CONSTANT_DEFINITION__IDENTIFIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.CONSTANT_DEFINITION__IDENTIFIER));
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.CONSTANT_DEFINITION__CONSTANT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.CONSTANT_DEFINITION__CONSTANT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConstantDefinitionAccess().getIdentifierIdentifierParserRuleCall_0_0(), semanticObject.getIdentifier());
		feeder.accept(grammarAccess.getConstantDefinitionAccess().getConstantConstantParserRuleCall_2_0(), semanticObject.getConstant());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     constant returns constant
	 *
	 * Constraint:
	 *     (
	 *         number=unsignedNumber | 
	 *         (sign=sign number1=unsignedNumber) | 
	 *         identifier=identifier | 
	 *         STRING_LITERAL=STRING_LITERAL | 
	 *         (sign2+=sign identifier1+=identifier) | 
	 *         constantChr=constantChr
	 *     )
	 */
	protected void sequence_constant(ISerializationContext context, constant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     variant returns constant
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             number=unsignedNumber | 
	 *             (sign=sign number1=unsignedNumber) | 
	 *             identifier=identifier | 
	 *             STRING_LITERAL=STRING_LITERAL | 
	 *             (sign2+=sign identifier1+=identifier) | 
	 *             constantChr=constantChr
	 *         ) 
	 *         constant+=constant* 
	 *         fieldList=fieldList
	 *     )
	 */
	protected void sequence_constant_variant(ISerializationContext context, constant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     expression returns expression
	 *
	 * Constraint:
	 *     (simpleExpression=simpleExpression (relationaloperator=relationaloperator expression=expression)?)
	 */
	protected void sequence_expression(ISerializationContext context, expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     factor returns factor
	 *
	 * Constraint:
	 *     (
	 *         expression=expression | 
	 *         unsignedConstant=unsignedConstant | 
	 *         factor=factor | 
	 *         bool=BOOL | 
	 *         functionDesignator=functionDesignator | 
	 *         variable=variable
	 *     )
	 */
	protected void sequence_factor(ISerializationContext context, factor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     fieldList returns fieldList
	 *
	 * Constraint:
	 *     ((fixedPart=fixedPart variantPart=variantPart?) | variantPart1+=variantPart)
	 */
	protected void sequence_fieldList(ISerializationContext context, fieldList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     fixedPart returns fixedPart
	 *
	 * Constraint:
	 *     (recordSection=recordSection recordSection1+=recordSection*)
	 */
	protected void sequence_fixedPart(ISerializationContext context, fixedPart semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     formalParameterList returns formalParameterList
	 *
	 * Constraint:
	 *     (formalParameterSection=formalParameterSection formalParameterSection2+=formalParameterSection*)
	 */
	protected void sequence_formalParameterList(ISerializationContext context, formalParameterList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     formalParameterSection returns formalParameterSection
	 *
	 * Constraint:
	 *     (parameterGroup=parameterGroup | parameterGroup2+=parameterGroup | parameterGroup3+=parameterGroup | parameterGroup4+=parameterGroup)
	 */
	protected void sequence_formalParameterSection(ISerializationContext context, formalParameterSection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     functionDeclaration returns functionDeclaration
	 *
	 * Constraint:
	 *     (identifier=identifier formalParameterList=formalParameterList? resultType=resultType block=block)
	 */
	protected void sequence_functionDeclaration(ISerializationContext context, functionDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     functionDesignator returns functionDesignator
	 *
	 * Constraint:
	 *     (identifier=identifier parameterList=parameterList)
	 */
	protected void sequence_functionDesignator(ISerializationContext context, functionDesignator semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.FUNCTION_DESIGNATOR__IDENTIFIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.FUNCTION_DESIGNATOR__IDENTIFIER));
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.FUNCTION_DESIGNATOR__PARAMETER_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.FUNCTION_DESIGNATOR__PARAMETER_LIST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFunctionDesignatorAccess().getIdentifierIdentifierParserRuleCall_0_0(), semanticObject.getIdentifier());
		feeder.accept(grammarAccess.getFunctionDesignatorAccess().getParameterListParameterListParserRuleCall_2_0(), semanticObject.getParameterList());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     functionType returns functionType
	 *
	 * Constraint:
	 *     (formalParameterList=formalParameterList? resultType=resultType)
	 */
	protected void sequence_functionType(ISerializationContext context, functionType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     gotoStatement returns gotoStatement
	 *
	 * Constraint:
	 *     label=label
	 */
	protected void sequence_gotoStatement(ISerializationContext context, gotoStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.GOTO_STATEMENT__LABEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.GOTO_STATEMENT__LABEL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGotoStatementAccess().getLabelLabelParserRuleCall_1_0(), semanticObject.getLabel());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     identifierList returns identifierList
	 *
	 * Constraint:
	 *     (identifier=identifier identifierList+=identifier*)
	 */
	protected void sequence_identifierList(ISerializationContext context, identifierList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     label returns label
	 *
	 * Constraint:
	 *     (unsignedInteger=unsignedInteger | identifier=identifier)
	 */
	protected void sequence_label(ISerializationContext context, label semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     label_declaration_part returns label
	 *
	 * Constraint:
	 *     ((unsignedInteger=unsignedInteger | identifier=identifier) label+=label*)
	 */
	protected void sequence_label_label_declaration_part(ISerializationContext context, label semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     statement returns label
	 *
	 * Constraint:
	 *     ((unsignedInteger=unsignedInteger | identifier=identifier) unlabelledStatement=unlabelledStatement)
	 */
	protected void sequence_label_statement(ISerializationContext context, label semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     parameterGroup returns parameterGroup
	 *
	 * Constraint:
	 *     (identifierList=identifierList typeIdentifier=typeIdentifier)
	 */
	protected void sequence_parameterGroup(ISerializationContext context, parameterGroup semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.PARAMETER_GROUP__IDENTIFIER_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.PARAMETER_GROUP__IDENTIFIER_LIST));
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.PARAMETER_GROUP__TYPE_IDENTIFIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.PARAMETER_GROUP__TYPE_IDENTIFIER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParameterGroupAccess().getIdentifierListIdentifierListParserRuleCall_0_0(), semanticObject.getIdentifierList());
		feeder.accept(grammarAccess.getParameterGroupAccess().getTypeIdentifierTypeIdentifierParserRuleCall_2_0(), semanticObject.getTypeIdentifier());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     pascal returns pascal
	 *
	 * Constraint:
	 *     program+=program
	 */
	protected void sequence_pascal(ISerializationContext context, pascal semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     pointerType returns pointerType
	 *
	 * Constraint:
	 *     typeIdentifier=typeIdentifier
	 */
	protected void sequence_pointerType(ISerializationContext context, pointerType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.POINTER_TYPE__TYPE_IDENTIFIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.POINTER_TYPE__TYPE_IDENTIFIER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPointerTypeAccess().getTypeIdentifierTypeIdentifierParserRuleCall_1_0(), semanticObject.getTypeIdentifier());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     procedureAndFunctionDeclarationPart returns procedureAndFunctionDeclarationPart
	 *
	 * Constraint:
	 *     procedureOrFunctionDeclaration=procedureOrFunctionDeclaration
	 */
	protected void sequence_procedureAndFunctionDeclarationPart(ISerializationContext context, procedureAndFunctionDeclarationPart semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.PROCEDURE_AND_FUNCTION_DECLARATION_PART__PROCEDURE_OR_FUNCTION_DECLARATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.PROCEDURE_AND_FUNCTION_DECLARATION_PART__PROCEDURE_OR_FUNCTION_DECLARATION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getProcedureAndFunctionDeclarationPartAccess().getProcedureOrFunctionDeclarationProcedureOrFunctionDeclarationParserRuleCall_0_0(), semanticObject.getProcedureOrFunctionDeclaration());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     procedureDeclaration returns procedureDeclaration
	 *
	 * Constraint:
	 *     (identifier=identifier formalParameterList=formalParameterList? block=block)
	 */
	protected void sequence_procedureDeclaration(ISerializationContext context, procedureDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     procedureOrFunctionDeclaration returns procedureOrFunctionDeclaration
	 *
	 * Constraint:
	 *     (procedureDeclaration=procedureDeclaration | functionDeclaration=functionDeclaration)
	 */
	protected void sequence_procedureOrFunctionDeclaration(ISerializationContext context, procedureOrFunctionDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     procedureType returns procedureType
	 *
	 * Constraint:
	 *     formalParameterList=formalParameterList?
	 */
	protected void sequence_procedureType(ISerializationContext context, procedureType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     programHeading returns programHeading
	 *
	 * Constraint:
	 *     (identifer=identifier identifierList=identifierList?)
	 */
	protected void sequence_programHeading(ISerializationContext context, programHeading semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     program returns program
	 *
	 * Constraint:
	 *     (head=programHeading block=block)
	 */
	protected void sequence_program(ISerializationContext context, program semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.PROGRAM__HEAD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.PROGRAM__HEAD));
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.PROGRAM__BLOCK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.PROGRAM__BLOCK));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getProgramAccess().getHeadProgramHeadingParserRuleCall_0_0(), semanticObject.getHead());
		feeder.accept(grammarAccess.getProgramAccess().getBlockBlockParserRuleCall_2_0(), semanticObject.getBlock());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     recordSection returns recordSection
	 *
	 * Constraint:
	 *     (identifierList=identifierList type=type)
	 */
	protected void sequence_recordSection(ISerializationContext context, recordSection semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.RECORD_SECTION__IDENTIFIER_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.RECORD_SECTION__IDENTIFIER_LIST));
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.RECORD_SECTION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.RECORD_SECTION__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRecordSectionAccess().getIdentifierListIdentifierListParserRuleCall_0_0(), semanticObject.getIdentifierList());
		feeder.accept(grammarAccess.getRecordSectionAccess().getTypeTypeParserRuleCall_2_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     recordType returns recordType
	 *
	 * Constraint:
	 *     fieldList=fieldList?
	 */
	protected void sequence_recordType(ISerializationContext context, recordType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     scalarType returns scalarType
	 *
	 * Constraint:
	 *     identifierList=identifierList
	 */
	protected void sequence_scalarType(ISerializationContext context, scalarType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.SCALAR_TYPE__IDENTIFIER_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.SCALAR_TYPE__IDENTIFIER_LIST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getScalarTypeAccess().getIdentifierListIdentifierListParserRuleCall_1_0(), semanticObject.getIdentifierList());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     signedFactor returns signedFactor
	 *
	 * Constraint:
	 *     factor=factor
	 */
	protected void sequence_signedFactor(ISerializationContext context, signedFactor semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.SIGNED_FACTOR__FACTOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.SIGNED_FACTOR__FACTOR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSignedFactorAccess().getFactorFactorParserRuleCall_1_0(), semanticObject.getFactor());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     simpleExpression returns simpleExpression
	 *
	 * Constraint:
	 *     (term=term (additiveoperator=additiveoperator simpleExpression=simpleExpression)?)
	 */
	protected void sequence_simpleExpression(ISerializationContext context, simpleExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     simpleStatement returns simpleStatement
	 *
	 * Constraint:
	 *     (gotoStatement=gotoStatement | assignmentStatement=assignmentStatement)?
	 */
	protected void sequence_simpleStatement(ISerializationContext context, simpleStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     simpleType returns simpleType
	 *
	 * Constraint:
	 *     (scalarType=scalarType | subrangeType=subrangeType | typeIdentifier=typeIdentifier | stringtype=stringtype)
	 */
	protected void sequence_simpleType(ISerializationContext context, simpleType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     statement returns statement
	 *
	 * Constraint:
	 *     unlabelledStatement=unlabelledStatement
	 */
	protected void sequence_statement(ISerializationContext context, statement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.STATEMENT__UNLABELLED_STATEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.STATEMENT__UNLABELLED_STATEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStatementAccess().getUnlabelledStatementUnlabelledStatementParserRuleCall_1_0(), semanticObject.getUnlabelledStatement());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     compoundStatement returns statements
	 *     statements returns statements
	 *
	 * Constraint:
	 *     (statement+=statement statement+=statement*)
	 */
	protected void sequence_statements(ISerializationContext context, statements semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     stringtype returns stringtype
	 *
	 * Constraint:
	 *     (identifier=identifier | unsignedNumber=unsignedNumber)
	 */
	protected void sequence_stringtype(ISerializationContext context, stringtype semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     structuredStatement returns structuredStatement
	 *
	 * Constraint:
	 *     (compoundStatement=compoundStatement | conditionalStatement=conditionalStatement)
	 */
	protected void sequence_structuredStatement(ISerializationContext context, structuredStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     structuredType returns structuredType
	 *
	 * Constraint:
	 *     (unpackedStructuredType=unpackedStructuredType | unpackedStructuredType1+=unpackedStructuredType)
	 */
	protected void sequence_structuredType(ISerializationContext context, structuredType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     subrangeType returns subrangeType
	 *
	 * Constraint:
	 *     (constant=constant constant2=constant)
	 */
	protected void sequence_subrangeType(ISerializationContext context, subrangeType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.SUBRANGE_TYPE__CONSTANT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.SUBRANGE_TYPE__CONSTANT));
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.SUBRANGE_TYPE__CONSTANT2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.SUBRANGE_TYPE__CONSTANT2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSubrangeTypeAccess().getConstantConstantParserRuleCall_0_0(), semanticObject.getConstant());
		feeder.accept(grammarAccess.getSubrangeTypeAccess().getConstant2ConstantParserRuleCall_2_0(), semanticObject.getConstant2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     tag returns tag
	 *
	 * Constraint:
	 *     ((identifier=identifier typeIdentifier=typeIdentifier) | typeIdentifier1+=typeIdentifier)
	 */
	protected void sequence_tag(ISerializationContext context, tag semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     term returns term
	 *
	 * Constraint:
	 *     (signedFactor=signedFactor (multiplicativeoperator=multiplicativeoperator term=term)?)
	 */
	protected void sequence_term(ISerializationContext context, term semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     typeDefinitionPart returns typeDefinitionPart
	 *
	 * Constraint:
	 *     typeDefinition+=typeDefinition+
	 */
	protected void sequence_typeDefinitionPart(ISerializationContext context, typeDefinitionPart semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     typeDefinition returns typeDefinition
	 *
	 * Constraint:
	 *     (indentifier+=identifier (type=type | functionType=functionType | procedureType=procedureType))
	 */
	protected void sequence_typeDefinition(ISerializationContext context, typeDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     resultType returns typeIdentifier
	 *     typeIdentifier returns typeIdentifier
	 *
	 * Constraint:
	 *     identifier=identifier?
	 */
	protected void sequence_typeIdentifier(ISerializationContext context, typeIdentifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     type returns type
	 *
	 * Constraint:
	 *     (simpleType=simpleType | structuredType=structuredType | pointerType=pointerType)
	 */
	protected void sequence_type(ISerializationContext context, type semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     unlabelledStatement returns unlabelledStatement
	 *
	 * Constraint:
	 *     (simpleStatement=simpleStatement | structuredStatement=structuredStatement | (identifier=identifier parameterList=parameterList?))
	 */
	protected void sequence_unlabelledStatement(ISerializationContext context, unlabelledStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     unpackedStructuredType returns unpackedStructuredType
	 *
	 * Constraint:
	 *     recordType=recordType
	 */
	protected void sequence_unpackedStructuredType(ISerializationContext context, unpackedStructuredType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.UNPACKED_STRUCTURED_TYPE__RECORD_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.UNPACKED_STRUCTURED_TYPE__RECORD_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnpackedStructuredTypeAccess().getRecordTypeRecordTypeParserRuleCall_0(), semanticObject.getRecordType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     unsignedConstant returns unsignedConstant
	 *
	 * Constraint:
	 *     (unsignedNumber=unsignedNumber | string_literal=STRING_LITERAL | constantChr=constantChr)?
	 */
	protected void sequence_unsignedConstant(ISerializationContext context, unsignedConstant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     unsignedInteger returns unsignedInteger
	 *
	 * Constraint:
	 *     number=NUM
	 */
	protected void sequence_unsignedInteger(ISerializationContext context, unsignedInteger semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.UNSIGNED_INTEGER__NUMBER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.UNSIGNED_INTEGER__NUMBER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnsignedIntegerAccess().getNumberNUMTerminalRuleCall_0(), semanticObject.getNumber());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     unsignedNumber returns unsignedNumber
	 *
	 * Constraint:
	 *     (unsignedInteger=unsignedInteger | unsignedReal=unsignedReal)
	 */
	protected void sequence_unsignedNumber(ISerializationContext context, unsignedNumber semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     usesUnitsPart returns usesUnitsPart
	 *
	 * Constraint:
	 *     identifierList=identifierList
	 */
	protected void sequence_usesUnitsPart(ISerializationContext context, usesUnitsPart semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.USES_UNITS_PART__IDENTIFIER_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.USES_UNITS_PART__IDENTIFIER_LIST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUsesUnitsPartAccess().getIdentifierListIdentifierListParserRuleCall_1_0(), semanticObject.getIdentifierList());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     variableDeclarationPart returns variableDeclarationPart
	 *
	 * Constraint:
	 *     (variableDeclaration=variableDeclaration variableDeclaration1+=variableDeclaration*)
	 */
	protected void sequence_variableDeclarationPart(ISerializationContext context, variableDeclarationPart semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     variableDeclaration returns variableDeclaration
	 *
	 * Constraint:
	 *     (identifierList=identifierList type=type expression=expression?)
	 */
	protected void sequence_variableDeclaration(ISerializationContext context, variableDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     variable returns variable
	 *
	 * Constraint:
	 *     (
	 *         (identifier=identifier | identifier=identifier) 
	 *         (identifier2+=identifier? (expression+=expression expression1+=expression*)? (expression2+=expression expression3+=expression*)?)+
	 *     )
	 */
	protected void sequence_variable(ISerializationContext context, variable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     variantPart returns variantPart
	 *
	 * Constraint:
	 *     (tag=tag variant=variant variant1+=variant*)
	 */
	protected void sequence_variantPart(ISerializationContext context, variantPart semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
