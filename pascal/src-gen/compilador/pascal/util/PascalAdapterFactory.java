/**
 * generated by Xtext 2.15.0
 */
package compilador.pascal.util;

import compilador.pascal.*;

import org.eclipse.emf.common.notify.Adapter;
import org.eclipse.emf.common.notify.Notifier;

import org.eclipse.emf.common.notify.impl.AdapterFactoryImpl;

import org.eclipse.emf.ecore.EObject;

/**
 * <!-- begin-user-doc -->
 * The <b>Adapter Factory</b> for the model.
 * It provides an adapter <code>createXXX</code> method for each class of the model.
 * <!-- end-user-doc -->
 * @see compilador.pascal.PascalPackage
 * @generated
 */
public class PascalAdapterFactory extends AdapterFactoryImpl
{
  /**
   * The cached model package.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  protected static PascalPackage modelPackage;

  /**
   * Creates an instance of the adapter factory.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public PascalAdapterFactory()
  {
    if (modelPackage == null)
    {
      modelPackage = PascalPackage.eINSTANCE;
    }
  }

  /**
   * Returns whether this factory is applicable for the type of the object.
   * <!-- begin-user-doc -->
   * This implementation returns <code>true</code> if the object is either the model's package or is an instance object of the model.
   * <!-- end-user-doc -->
   * @return whether this factory is applicable for the type of the object.
   * @generated
   */
  @Override
  public boolean isFactoryForType(Object object)
  {
    if (object == modelPackage)
    {
      return true;
    }
    if (object instanceof EObject)
    {
      return ((EObject)object).eClass().getEPackage() == modelPackage;
    }
    return false;
  }

  /**
   * The switch that delegates to the <code>createXXX</code> methods.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  protected PascalSwitch<Adapter> modelSwitch =
    new PascalSwitch<Adapter>()
    {
      @Override
      public Adapter casepascal(pascal object)
      {
        return createpascalAdapter();
      }
      @Override
      public Adapter caseprogram(program object)
      {
        return createprogramAdapter();
      }
      @Override
      public Adapter caseprogramHeading(programHeading object)
      {
        return createprogramHeadingAdapter();
      }
      @Override
      public Adapter caseidentifierList(identifierList object)
      {
        return createidentifierListAdapter();
      }
      @Override
      public Adapter caseidentifier(identifier object)
      {
        return createidentifierAdapter();
      }
      @Override
      public Adapter caseblock(block object)
      {
        return createblockAdapter();
      }
      @Override
      public Adapter caselabel_declaration_part(label_declaration_part object)
      {
        return createlabel_declaration_partAdapter();
      }
      @Override
      public Adapter caselabel(label object)
      {
        return createlabelAdapter();
      }
      @Override
      public Adapter caseunsignedInteger(unsignedInteger object)
      {
        return createunsignedIntegerAdapter();
      }
      @Override
      public Adapter caseconstantDefinitionPart(constantDefinitionPart object)
      {
        return createconstantDefinitionPartAdapter();
      }
      @Override
      public Adapter caseconstantDefinition(constantDefinition object)
      {
        return createconstantDefinitionAdapter();
      }
      @Override
      public Adapter caseconstant(constant object)
      {
        return createconstantAdapter();
      }
      @Override
      public Adapter caseconstantChr(constantChr object)
      {
        return createconstantChrAdapter();
      }
      @Override
      public Adapter caseunsignedNumber(unsignedNumber object)
      {
        return createunsignedNumberAdapter();
      }
      @Override
      public Adapter caseusesUnitsPart(usesUnitsPart object)
      {
        return createusesUnitsPartAdapter();
      }
      @Override
      public Adapter casetypeDefinitionPart(typeDefinitionPart object)
      {
        return createtypeDefinitionPartAdapter();
      }
      @Override
      public Adapter casetypeDefinition(typeDefinition object)
      {
        return createtypeDefinitionAdapter();
      }
      @Override
      public Adapter casefunctionType(functionType object)
      {
        return createfunctionTypeAdapter();
      }
      @Override
      public Adapter caseresultType(resultType object)
      {
        return createresultTypeAdapter();
      }
      @Override
      public Adapter caseformalParameterList(formalParameterList object)
      {
        return createformalParameterListAdapter();
      }
      @Override
      public Adapter caseformalParameterSection(formalParameterSection object)
      {
        return createformalParameterSectionAdapter();
      }
      @Override
      public Adapter caseparameterGroup(parameterGroup object)
      {
        return createparameterGroupAdapter();
      }
      @Override
      public Adapter casetypeIdentifier(typeIdentifier object)
      {
        return createtypeIdentifierAdapter();
      }
      @Override
      public Adapter caseprocedureType(procedureType object)
      {
        return createprocedureTypeAdapter();
      }
      @Override
      public Adapter casetype(type object)
      {
        return createtypeAdapter();
      }
      @Override
      public Adapter casepointerType(pointerType object)
      {
        return createpointerTypeAdapter();
      }
      @Override
      public Adapter casesimpleType(simpleType object)
      {
        return createsimpleTypeAdapter();
      }
      @Override
      public Adapter casescalarType(scalarType object)
      {
        return createscalarTypeAdapter();
      }
      @Override
      public Adapter casesubrangeType(subrangeType object)
      {
        return createsubrangeTypeAdapter();
      }
      @Override
      public Adapter casestructuredType(structuredType object)
      {
        return createstructuredTypeAdapter();
      }
      @Override
      public Adapter caseunpackedStructuredType(unpackedStructuredType object)
      {
        return createunpackedStructuredTypeAdapter();
      }
      @Override
      public Adapter casestringtype(stringtype object)
      {
        return createstringtypeAdapter();
      }
      @Override
      public Adapter caserecordType(recordType object)
      {
        return createrecordTypeAdapter();
      }
      @Override
      public Adapter casefieldList(fieldList object)
      {
        return createfieldListAdapter();
      }
      @Override
      public Adapter casefixedPart(fixedPart object)
      {
        return createfixedPartAdapter();
      }
      @Override
      public Adapter caserecordSection(recordSection object)
      {
        return createrecordSectionAdapter();
      }
      @Override
      public Adapter casevariantPart(variantPart object)
      {
        return createvariantPartAdapter();
      }
      @Override
      public Adapter casetag(tag object)
      {
        return createtagAdapter();
      }
      @Override
      public Adapter casevariant(variant object)
      {
        return createvariantAdapter();
      }
      @Override
      public Adapter caseconstList(constList object)
      {
        return createconstListAdapter();
      }
      @Override
      public Adapter casevariableDeclarationPart(variableDeclarationPart object)
      {
        return createvariableDeclarationPartAdapter();
      }
      @Override
      public Adapter casevariableDeclaration(variableDeclaration object)
      {
        return createvariableDeclarationAdapter();
      }
      @Override
      public Adapter caseprocedureAndFunctionDeclarationPart(procedureAndFunctionDeclarationPart object)
      {
        return createprocedureAndFunctionDeclarationPartAdapter();
      }
      @Override
      public Adapter caseprocedureOrFunctionDeclaration(procedureOrFunctionDeclaration object)
      {
        return createprocedureOrFunctionDeclarationAdapter();
      }
      @Override
      public Adapter caseprocedureDeclaration(procedureDeclaration object)
      {
        return createprocedureDeclarationAdapter();
      }
      @Override
      public Adapter casefunctionDeclaration(functionDeclaration object)
      {
        return createfunctionDeclarationAdapter();
      }
      @Override
      public Adapter casestatement(statement object)
      {
        return createstatementAdapter();
      }
      @Override
      public Adapter caseunlabelledStatement(unlabelledStatement object)
      {
        return createunlabelledStatementAdapter();
      }
      @Override
      public Adapter casesimpleStatement(simpleStatement object)
      {
        return createsimpleStatementAdapter();
      }
      @Override
      public Adapter caseassignmentStatement(assignmentStatement object)
      {
        return createassignmentStatementAdapter();
      }
      @Override
      public Adapter casevariable(variable object)
      {
        return createvariableAdapter();
      }
      @Override
      public Adapter caseexpression(expression object)
      {
        return createexpressionAdapter();
      }
      @Override
      public Adapter casesimpleExpression(simpleExpression object)
      {
        return createsimpleExpressionAdapter();
      }
      @Override
      public Adapter caseterm(term object)
      {
        return createtermAdapter();
      }
      @Override
      public Adapter casesignedFactor(signedFactor object)
      {
        return createsignedFactorAdapter();
      }
      @Override
      public Adapter casefactor(factor object)
      {
        return createfactorAdapter();
      }
      @Override
      public Adapter caseunsignedConstant(unsignedConstant object)
      {
        return createunsignedConstantAdapter();
      }
      @Override
      public Adapter casefunctionDesignator(functionDesignator object)
      {
        return createfunctionDesignatorAdapter();
      }
      @Override
      public Adapter caseparameterList(parameterList object)
      {
        return createparameterListAdapter();
      }
      @Override
      public Adapter caseactualParameter(actualParameter object)
      {
        return createactualParameterAdapter();
      }
      @Override
      public Adapter casegotoStatement(gotoStatement object)
      {
        return creategotoStatementAdapter();
      }
      @Override
      public Adapter casestructuredStatement(structuredStatement object)
      {
        return createstructuredStatementAdapter();
      }
      @Override
      public Adapter casecompoundStatement(compoundStatement object)
      {
        return createcompoundStatementAdapter();
      }
      @Override
      public Adapter casestatements(statements object)
      {
        return createstatementsAdapter();
      }
      @Override
      public Adapter caseconditionalStatement(conditionalStatement object)
      {
        return createconditionalStatementAdapter();
      }
      @Override
      public Adapter casecaseStatement(caseStatement object)
      {
        return createcaseStatementAdapter();
      }
      @Override
      public Adapter casecaseListElement(caseListElement object)
      {
        return createcaseListElementAdapter();
      }
      @Override
      public Adapter defaultCase(EObject object)
      {
        return createEObjectAdapter();
      }
    };

  /**
   * Creates an adapter for the <code>target</code>.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @param target the object to adapt.
   * @return the adapter for the <code>target</code>.
   * @generated
   */
  @Override
  public Adapter createAdapter(Notifier target)
  {
    return modelSwitch.doSwitch((EObject)target);
  }


  /**
   * Creates a new adapter for an object of class '{@link compilador.pascal.pascal <em>pascal</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see compilador.pascal.pascal
   * @generated
   */
  public Adapter createpascalAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link compilador.pascal.program <em>program</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see compilador.pascal.program
   * @generated
   */
  public Adapter createprogramAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link compilador.pascal.programHeading <em>program Heading</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see compilador.pascal.programHeading
   * @generated
   */
  public Adapter createprogramHeadingAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link compilador.pascal.identifierList <em>identifier List</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see compilador.pascal.identifierList
   * @generated
   */
  public Adapter createidentifierListAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link compilador.pascal.identifier <em>identifier</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see compilador.pascal.identifier
   * @generated
   */
  public Adapter createidentifierAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link compilador.pascal.block <em>block</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see compilador.pascal.block
   * @generated
   */
  public Adapter createblockAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link compilador.pascal.label_declaration_part <em>label declaration part</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see compilador.pascal.label_declaration_part
   * @generated
   */
  public Adapter createlabel_declaration_partAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link compilador.pascal.label <em>label</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see compilador.pascal.label
   * @generated
   */
  public Adapter createlabelAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link compilador.pascal.unsignedInteger <em>unsigned Integer</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see compilador.pascal.unsignedInteger
   * @generated
   */
  public Adapter createunsignedIntegerAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link compilador.pascal.constantDefinitionPart <em>constant Definition Part</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see compilador.pascal.constantDefinitionPart
   * @generated
   */
  public Adapter createconstantDefinitionPartAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link compilador.pascal.constantDefinition <em>constant Definition</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see compilador.pascal.constantDefinition
   * @generated
   */
  public Adapter createconstantDefinitionAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link compilador.pascal.constant <em>constant</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see compilador.pascal.constant
   * @generated
   */
  public Adapter createconstantAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link compilador.pascal.constantChr <em>constant Chr</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see compilador.pascal.constantChr
   * @generated
   */
  public Adapter createconstantChrAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link compilador.pascal.unsignedNumber <em>unsigned Number</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see compilador.pascal.unsignedNumber
   * @generated
   */
  public Adapter createunsignedNumberAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link compilador.pascal.usesUnitsPart <em>uses Units Part</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see compilador.pascal.usesUnitsPart
   * @generated
   */
  public Adapter createusesUnitsPartAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link compilador.pascal.typeDefinitionPart <em>type Definition Part</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see compilador.pascal.typeDefinitionPart
   * @generated
   */
  public Adapter createtypeDefinitionPartAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link compilador.pascal.typeDefinition <em>type Definition</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see compilador.pascal.typeDefinition
   * @generated
   */
  public Adapter createtypeDefinitionAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link compilador.pascal.functionType <em>function Type</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see compilador.pascal.functionType
   * @generated
   */
  public Adapter createfunctionTypeAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link compilador.pascal.resultType <em>result Type</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see compilador.pascal.resultType
   * @generated
   */
  public Adapter createresultTypeAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link compilador.pascal.formalParameterList <em>formal Parameter List</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see compilador.pascal.formalParameterList
   * @generated
   */
  public Adapter createformalParameterListAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link compilador.pascal.formalParameterSection <em>formal Parameter Section</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see compilador.pascal.formalParameterSection
   * @generated
   */
  public Adapter createformalParameterSectionAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link compilador.pascal.parameterGroup <em>parameter Group</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see compilador.pascal.parameterGroup
   * @generated
   */
  public Adapter createparameterGroupAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link compilador.pascal.typeIdentifier <em>type Identifier</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see compilador.pascal.typeIdentifier
   * @generated
   */
  public Adapter createtypeIdentifierAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link compilador.pascal.procedureType <em>procedure Type</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see compilador.pascal.procedureType
   * @generated
   */
  public Adapter createprocedureTypeAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link compilador.pascal.type <em>type</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see compilador.pascal.type
   * @generated
   */
  public Adapter createtypeAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link compilador.pascal.pointerType <em>pointer Type</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see compilador.pascal.pointerType
   * @generated
   */
  public Adapter createpointerTypeAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link compilador.pascal.simpleType <em>simple Type</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see compilador.pascal.simpleType
   * @generated
   */
  public Adapter createsimpleTypeAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link compilador.pascal.scalarType <em>scalar Type</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see compilador.pascal.scalarType
   * @generated
   */
  public Adapter createscalarTypeAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link compilador.pascal.subrangeType <em>subrange Type</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see compilador.pascal.subrangeType
   * @generated
   */
  public Adapter createsubrangeTypeAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link compilador.pascal.structuredType <em>structured Type</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see compilador.pascal.structuredType
   * @generated
   */
  public Adapter createstructuredTypeAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link compilador.pascal.unpackedStructuredType <em>unpacked Structured Type</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see compilador.pascal.unpackedStructuredType
   * @generated
   */
  public Adapter createunpackedStructuredTypeAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link compilador.pascal.stringtype <em>stringtype</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see compilador.pascal.stringtype
   * @generated
   */
  public Adapter createstringtypeAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link compilador.pascal.recordType <em>record Type</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see compilador.pascal.recordType
   * @generated
   */
  public Adapter createrecordTypeAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link compilador.pascal.fieldList <em>field List</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see compilador.pascal.fieldList
   * @generated
   */
  public Adapter createfieldListAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link compilador.pascal.fixedPart <em>fixed Part</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see compilador.pascal.fixedPart
   * @generated
   */
  public Adapter createfixedPartAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link compilador.pascal.recordSection <em>record Section</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see compilador.pascal.recordSection
   * @generated
   */
  public Adapter createrecordSectionAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link compilador.pascal.variantPart <em>variant Part</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see compilador.pascal.variantPart
   * @generated
   */
  public Adapter createvariantPartAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link compilador.pascal.tag <em>tag</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see compilador.pascal.tag
   * @generated
   */
  public Adapter createtagAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link compilador.pascal.variant <em>variant</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see compilador.pascal.variant
   * @generated
   */
  public Adapter createvariantAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link compilador.pascal.constList <em>const List</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see compilador.pascal.constList
   * @generated
   */
  public Adapter createconstListAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link compilador.pascal.variableDeclarationPart <em>variable Declaration Part</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see compilador.pascal.variableDeclarationPart
   * @generated
   */
  public Adapter createvariableDeclarationPartAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link compilador.pascal.variableDeclaration <em>variable Declaration</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see compilador.pascal.variableDeclaration
   * @generated
   */
  public Adapter createvariableDeclarationAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link compilador.pascal.procedureAndFunctionDeclarationPart <em>procedure And Function Declaration Part</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see compilador.pascal.procedureAndFunctionDeclarationPart
   * @generated
   */
  public Adapter createprocedureAndFunctionDeclarationPartAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link compilador.pascal.procedureOrFunctionDeclaration <em>procedure Or Function Declaration</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see compilador.pascal.procedureOrFunctionDeclaration
   * @generated
   */
  public Adapter createprocedureOrFunctionDeclarationAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link compilador.pascal.procedureDeclaration <em>procedure Declaration</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see compilador.pascal.procedureDeclaration
   * @generated
   */
  public Adapter createprocedureDeclarationAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link compilador.pascal.functionDeclaration <em>function Declaration</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see compilador.pascal.functionDeclaration
   * @generated
   */
  public Adapter createfunctionDeclarationAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link compilador.pascal.statement <em>statement</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see compilador.pascal.statement
   * @generated
   */
  public Adapter createstatementAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link compilador.pascal.unlabelledStatement <em>unlabelled Statement</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see compilador.pascal.unlabelledStatement
   * @generated
   */
  public Adapter createunlabelledStatementAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link compilador.pascal.simpleStatement <em>simple Statement</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see compilador.pascal.simpleStatement
   * @generated
   */
  public Adapter createsimpleStatementAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link compilador.pascal.assignmentStatement <em>assignment Statement</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see compilador.pascal.assignmentStatement
   * @generated
   */
  public Adapter createassignmentStatementAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link compilador.pascal.variable <em>variable</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see compilador.pascal.variable
   * @generated
   */
  public Adapter createvariableAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link compilador.pascal.expression <em>expression</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see compilador.pascal.expression
   * @generated
   */
  public Adapter createexpressionAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link compilador.pascal.simpleExpression <em>simple Expression</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see compilador.pascal.simpleExpression
   * @generated
   */
  public Adapter createsimpleExpressionAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link compilador.pascal.term <em>term</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see compilador.pascal.term
   * @generated
   */
  public Adapter createtermAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link compilador.pascal.signedFactor <em>signed Factor</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see compilador.pascal.signedFactor
   * @generated
   */
  public Adapter createsignedFactorAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link compilador.pascal.factor <em>factor</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see compilador.pascal.factor
   * @generated
   */
  public Adapter createfactorAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link compilador.pascal.unsignedConstant <em>unsigned Constant</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see compilador.pascal.unsignedConstant
   * @generated
   */
  public Adapter createunsignedConstantAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link compilador.pascal.functionDesignator <em>function Designator</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see compilador.pascal.functionDesignator
   * @generated
   */
  public Adapter createfunctionDesignatorAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link compilador.pascal.parameterList <em>parameter List</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see compilador.pascal.parameterList
   * @generated
   */
  public Adapter createparameterListAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link compilador.pascal.actualParameter <em>actual Parameter</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see compilador.pascal.actualParameter
   * @generated
   */
  public Adapter createactualParameterAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link compilador.pascal.gotoStatement <em>goto Statement</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see compilador.pascal.gotoStatement
   * @generated
   */
  public Adapter creategotoStatementAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link compilador.pascal.structuredStatement <em>structured Statement</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see compilador.pascal.structuredStatement
   * @generated
   */
  public Adapter createstructuredStatementAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link compilador.pascal.compoundStatement <em>compound Statement</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see compilador.pascal.compoundStatement
   * @generated
   */
  public Adapter createcompoundStatementAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link compilador.pascal.statements <em>statements</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see compilador.pascal.statements
   * @generated
   */
  public Adapter createstatementsAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link compilador.pascal.conditionalStatement <em>conditional Statement</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see compilador.pascal.conditionalStatement
   * @generated
   */
  public Adapter createconditionalStatementAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link compilador.pascal.caseStatement <em>case Statement</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see compilador.pascal.caseStatement
   * @generated
   */
  public Adapter createcaseStatementAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link compilador.pascal.caseListElement <em>case List Element</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see compilador.pascal.caseListElement
   * @generated
   */
  public Adapter createcaseListElementAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for the default case.
   * <!-- begin-user-doc -->
   * This default implementation returns null.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @generated
   */
  public Adapter createEObjectAdapter()
  {
    return null;
  }

} //PascalAdapterFactory
